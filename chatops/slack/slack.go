package slack

import (
	"bytes"
	"crypto/tls"
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http"
	"strings"
)

// Payload is what is needed to send a slack message
type Payload struct {
	Client  *Client
	Message *MessageEnvelope
}

// Client is the webhook URL generated by the incoming-webhook slack app
type Client struct {
	WebHookURL string
}

// MessageEnvelope is for the complete slack message
type MessageEnvelope struct {
	Text        string                `json:"text,omitempty"`
	Attachments []*MessageAttachments `json:"attachments,omitempty"`
	Parse       string                `json:"parse,omitempty"`
	Username    string                `json:"username,omitempty"`
	IconUrl     string                `json:"icon_url,omitempty"`
	IconEmoji   string                `json:"icon_emoji,omitempty"`
	Channel     string                `json:"channel,omitempty"`
	LinkNames   string                `json:"link_names,omitempty"`
	UnfurlLinks bool                  `json:"unfurl_links,omitempty"`
	UnfurlMedia bool                  `json:"unfurl_media,omitempty"`
	MarkdownIn  []string              `json:"mrkdwn_in,omitempty"`
	Markdown    bool                  `json:"mrkdwn,omitempty"`
}

// MessageAttachments is for the attachment options in MessageEnvelope
type MessageAttachments struct {
	Fallback   string               `json:"fallback,omitempty"`
	Actions    []*AttachmentActions `json:"actions,omitempty"`
	Color      string               `json:"color,omitempty"` //good, warning, danger, or a hex value
	Pretext    string               `json:"pretext,omitempty"`
	AuthorName string               `json:"author_name,omitempty"`
	AuthorLink string               `json:"author_link,omitempty"`
	AuthorIcon string               `json:"author_icon,omitempty"`
	Title      string               `json:"title,omitempty"`
	TitleLink  string               `json:"title_link,omitempty"`
	Text       string               `json:"text,omitempty"`
	Fields     []*AttachmentFields  `json:"fields,omitempty"`
	ImageURL   string               `json:"image_url,omitempty"`
	ThumbURL   string               `json:"thumb_url,omitempty"`
	MarkdownIn []string             `json:"mrkdwn_in,omitempty"`
	Markdown   bool                 `json:"mrkdwn,omitempty"`
	Footer     string               `json:"footer,omitempty"`
	FooterIcon string               `json:"footer_icon,omitempty"`
	Ts         int                  `json:"ts,omitempty"`
}

// AttachmentActions is for the action options in MessageAttachments
type AttachmentActions struct {
	Type    string                    `json:"type,omitempty"`
	Text    string                    `json:"text,omitempty"`
	URL     string                    `json:"url,omitempty"`
	Style   string                    `json:"style,omitempty"`
	Value   string                    `json:"value,omitempty"`
	Name    string                    `json:"name,omitempty"`
	Confirm *AttachmentActionsConfirm `json:"confirm,omitempty"`
}

// AttachmentActionsConfirm is for the confirm options in AttachmentActions
type AttachmentActionsConfirm struct {
	Title       string `json:"title,omitempty"`
	Text        string `json:"text,omitempty"`
	OkText      string `json:"ok_text,omitempty"`
	DismissText string `json:"dismiss_text,omitempty"`
}

// AttachmentFields is for the fields options in MessageAttachments
type AttachmentFields struct {
	Title string      `json:"title,omitempty"`
	Value interface{} `json:"value,omitempty"`
	Short bool        `json:"short,omitempty"`
}

// NewClientURL returns client webhook URL
func (p *Payload) NewClientURL() string {

	if p.Client.WebHookURL == "" {
		p.Client.WebHookURL = "Webhook required"
	}
	return p.Client.WebHookURL
}

// NewMessage formats the MessageEnvelope into a *bytes.Reader for the HTTP POST
func (p *Payload) NewMessage() (*bytes.Reader, error) {
	data, err := json.Marshal(p.Message)
	if err != nil {
		return nil, err
	}
	if len(data) <= 2 || strings.Contains(string(data), "null") {
		return nil, errors.New("Message format is not correct")
	}
	body := bytes.NewReader(data)
	return body, err

}

//SendMessage takes a payload and sends to slack
func (p *Payload) SendMessage() error {

	webHookURL := p.NewClientURL()
	message, err := p.NewMessage()
	if err != nil {
		return err
	}

	//TODO: Add option for cert bundle
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}

	res, err := client.Post(webHookURL, "application/json", message)

	if err != nil {
		return err
	}
	defer res.Body.Close()

	_, err = ioutil.ReadAll(res.Body)
	if err != nil {
		return err
	}

	return nil
}
